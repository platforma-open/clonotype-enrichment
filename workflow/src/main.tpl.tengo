// "hello world"
wf := import("@platforma-sdk/workflow-tengo:workflow")
exec := import("@platforma-sdk/workflow-tengo:exec")
assets:= import("@platforma-sdk/workflow-tengo:assets")
xsv := import("@platforma-sdk/workflow-tengo:pframes.xsv")
pframes := import("@platforma-sdk/workflow-tengo:pframes")
render := import("@platforma-sdk/workflow-tengo:render")
pSpec := import("@platforma-sdk/workflow-tengo:pframes.spec")
json := import("json")
strings := import("@platforma-sdk/workflow-tengo:strings")
text := import("text")

buildMainExportTpl := assets.importTemplate(":build-main-export")
enrichmentColumnTpl := assets.importTemplate(":enrichment-column")
downsamplingSw := assets.importSoftware("@platforma-open/milaboratories.clonotype-enrichment.software:downsampling")

pfEnrichmentConv := import(":pf-enrichment-conv")
pfFrequencyConv := import(":pf-frequency-conv")
pfBubbleConv := import(":pf-bubble-conv")
pfStackedConv := import(":pf-stacked-conv")
pfControlScatterConv := import(":pf-control-scatter-conv")

// Helper function to calculate annotation values for enrichment data
calculateAnnotationValues := func(inputFile, enrichmentColumn) {
	annotationValues := exec.builder().
		software(assets.importSoftware("@platforma-open/milaboratories.clonotype-enrichment.software:calculate-annotations")).
		mem("16GiB").
		cpu(1).
		addFile("inputFile.csv", inputFile).
		arg("inputFile.csv").
		arg("--enrichment-column").arg(enrichmentColumn).
		saveFileContent("enrichment_min.txt"). 
		saveFileContent("enrichment_max.txt").
		saveFileContent("enrichment_median.txt").
		saveFileContent("enrichment_mean.txt").
		saveFileContent("enrichment_75.txt").
		saveFileContent("overall_75.txt").
		printErrStreamToStdout().
		saveStdoutContent().
		run()

	return {
		min: annotationValues.getFileContent("enrichment_min.txt"),
		max: annotationValues.getFileContent("enrichment_max.txt"),
		median: annotationValues.getFileContent("enrichment_median.txt"),
		mean: annotationValues.getFileContent("enrichment_mean.txt"),
		cutoff: annotationValues.getFileContent("enrichment_75.txt"),
		overall75Percentile: annotationValues.getFileContent("overall_75.txt")
	}
}

wf.prepare(func(args){

	bundleBuilder := wf.createPBundleBuilder()
	bundleBuilder.addAnchor("main", args.abundanceRef) 
	bundleBuilder.addSingle(args.conditionColumnRef)

	if args.antigenControlConfig.antigenEnabled && args.antigenControlConfig.antigenColumnRef != undefined {
		bundleBuilder.addSingle(args.antigenControlConfig.antigenColumnRef)
	}

	if args.clonotypeDefinition != undefined {
        for columnRef in args.clonotypeDefinition {
            bundleBuilder.addSingle(columnRef)
        }
    }

	return {
		columns: bundleBuilder.build()
	}
})

wf.body(func(args) {

	// Load input parameters and related variables
	blockId := wf.blockId().getDataAsJson()
	columns := args.columns
	conditionOrder := args.conditionOrder
	abundanceSpec := columns.getSpec(args.abundanceRef)
	downsampling:= args.downsampling
	additionalEnrichmentExports := args.additionalEnrichmentExports
	antigenControlConfig := args.antigenControlConfig

	// Prepare trace label (Frequencies are always the same, so we don't need to add the condition order)
	// Downsampling will cause it to change, so lets add it
	// Filtering will also cause changes, so include filtering mode
	label := ""
	if downsampling.type == "hypergeometric" {
		if downsampling.valueChooser == "fixed" {
			label = "Downsampling: " + downsampling.type + " - " + downsampling.valueChooser + " - " + string(downsampling.n)
		} else {
			label = "Downsampling: " + downsampling.type + " - " + downsampling.valueChooser
		}
	} else {
		label = "Downsampling: " + downsampling.type
	}
	
	// Add filtering mode to ensure cache differentiation
	FilteringConfig := args.FilteringConfig
	label = label + " - Filtering: " + FilteringConfig.baseFilter

	if args.pseudoCount > 0 {
		label = label + " - Pseudo: " + string(args.pseudoCount)
	}

	// Get abundance table
	cloneTable := pframes.csvFileBuilder() 
	cloneTable.add(columns.getColumn(args.abundanceRef), {header: "abundance"})
	cloneTable.add(columns.getColumn(args.conditionColumnRef), {header: "condition"})
	if antigenControlConfig.antigenEnabled {
		cloneTable.add(columns.getColumn(antigenControlConfig.antigenColumnRef), {header: "antigen"})
	}
	cloneTable.setAxisHeader(abundanceSpec.axesSpec[0].name, "sampleId")
	cloneTable.setAxisHeader(abundanceSpec.axesSpec[1].name, "elementId")
	cloneTable.mem("32GiB")
	cloneTable.cpu(1)
	cloneTable = cloneTable.build()

	clonotypeDefinitionFile := undefined
    if args.clonotypeDefinition != undefined && len(args.clonotypeDefinition) > 0 {
        clonotypeDefinitionTable := pframes.csvFileBuilder()
        for i, columnRef in args.clonotypeDefinition {
            clonotypeDefinitionTable.add(columns.getColumn(columnRef), {header: "clonotypeDefinition_" + i})
        }
        clonotypeDefinitionTable.setAxisHeader(abundanceSpec.axesSpec[1].name, "elementId")
        clonotypeDefinitionTable.mem("16GiB")
        clonotypeDefinitionTable.cpu(1)
        clonotypeDefinitionFile = clonotypeDefinitionTable.build()
    }

	runDownsampling := exec.builder().
		software(downsamplingSw).
		mem("32GiB").
		cpu(8).
		writeFile("downsampling.json", json.encode(downsampling)).
		addFile("input.csv", cloneTable).
		saveFile("result.csv").
		run()
	downsamplingFile := runDownsampling.getFile("result.csv")
	
	// Check if inputs are individual clonotypes or clusters
	inputType := "Unknown"
	if abundanceSpec.axesSpec[1].name == "pl7.app/vdj/clusterId" {
		inputType = "Cluster"
	} else if abundanceSpec.axesSpec[1].name == "pl7.app/vdj/clonotypeKey" || 
				abundanceSpec.axesSpec[1].name == "pl7.app/vdj/scClonotypeKey" {
		inputType = "Clonotype"
	}
	
	//////////// Enrichment analysis ////////////
	// Run enrichment script with boolean filtering flags for reliable cache differentiation
	calculateEnrichment := exec.builder().
		software(assets.importSoftware("@platforma-open/milaboratories.clonotype-enrichment.software:calculate-enrichment")).
		mem("32GiB").
		cpu(8).
		addFile("inputFile.csv", downsamplingFile).
		arg("--input_data").arg("inputFile.csv").
		arg("--conditions").arg(string(conditionOrder)).
		arg("--enrichment_threshold").arg(string(args.enrichmentThreshold)).
		arg("--enrichment").arg("enrichment_results.csv").
		arg("--bubble").arg("bubble_data.csv").
		arg("--top_enriched").arg("top_enriched.csv").
		arg("--top_10").arg("top_10.csv").
		arg("--pseudo_count").arg(string(args.pseudoCount)).
		// arg("--min_enrichment").arg(string(enrichmentThreshold)).
		arg("--highest_enrichment_clonotype").arg("highest_enrichment_clonotype.csv").
		arg("--filtered_too_much").arg("filtered_too_much.txt")

	if clonotypeDefinitionFile != undefined {
        calculateEnrichment = calculateEnrichment.addFile("clonotypeDefinition.csv", clonotypeDefinitionFile).
		    arg("--clonotype-definition").arg("clonotypeDefinition.csv")
    }

	if antigenControlConfig.antigenEnabled || antigenControlConfig.controlEnabled {
		calculateEnrichment = calculateEnrichment.
			arg("--current_target").arg(string(antigenControlConfig.targetAntigen))

		if antigenControlConfig.sequencedLibraryEnabled {
			calculateEnrichment = calculateEnrichment.
				arg("--sequenced_library_enabled").
				arg("--sequenced_library_sample_id").arg(string(antigenControlConfig.sequencedLibrarySampleId))
		}
		
		if antigenControlConfig.controlEnabled {
			calculateEnrichment = calculateEnrichment.
				arg("--control_enabled").
				arg("--negative_antigens").arg(string(antigenControlConfig.negativeAntigens)).
				arg("--control_conditions_order").arg(string(antigenControlConfig.controlConditionsOrder)).
				arg("--control_threshold").arg(string(antigenControlConfig.controlThreshold)).
				// arg("--single_control_fc_threshold").arg(string(antigenControlConfig.singleControlFoldChangeThreshold)).
				arg("--single_control_frequency_threshold").arg(string(antigenControlConfig.singleControlFrequencyThreshold))
		}
	}

	// Add filtering flags based on user selection
	if FilteringConfig.baseFilter != "none" {
		calculateEnrichment = calculateEnrichment.arg("--filter_clonotypes")
		
		if FilteringConfig.baseFilter == "single-sample" {
			calculateEnrichment = calculateEnrichment.arg("--filter_single_sample")
		} else if FilteringConfig.baseFilter == "shared" {
			calculateEnrichment = calculateEnrichment.arg("--filter_any_zero")
		}
	}

	// Apply minimum abundance filters based on selection
	if FilteringConfig.minAbundance.enabled {
		label = label + " - (" + FilteringConfig.minAbundance.metric + ", " + string(FilteringConfig.minAbundance.threshold) + ")"

		calculateEnrichment = calculateEnrichment.arg("--filter_clonotypes")
		if FilteringConfig.minAbundance.metric == "count" {
			calculateEnrichment = calculateEnrichment.arg("--min_abundance").arg(string(FilteringConfig.minAbundance.threshold))
		} else if FilteringConfig.minAbundance.metric == "frequency" {
			calculateEnrichment = calculateEnrichment.arg("--min_frequency").arg(string(FilteringConfig.minAbundance.threshold))
		}
	}

	// Apply in-round presence filters based on selection
	if FilteringConfig.presentInRounds.enabled {
		label = label + " - (" + FilteringConfig.presentInRounds.logic + ", " + string(FilteringConfig.presentInRounds.rounds) + ")"
		
		calculateEnrichment = calculateEnrichment.arg("--filter_clonotypes")
		calculateEnrichment = calculateEnrichment.arg("--present_in_rounds").arg(string(FilteringConfig.presentInRounds.rounds))
		calculateEnrichment = calculateEnrichment.arg("--present_in_rounds_logic").arg(FilteringConfig.presentInRounds.logic)
	}

	calculateEnrichment = calculateEnrichment.
		saveFile("enrichment_results.csv").
		saveFile("bubble_data.csv").
		saveFile("top_enriched.csv").
		saveFile("top_10.csv").
		saveFile("highest_enrichment_clonotype.csv").
		saveFileContent("filtered_too_much.txt").
		printErrStreamToStdout().
		saveStdoutContent().
		run()

	// Convert script outputs to Pframes
	enrichCsv := calculateEnrichment.getFile("enrichment_results.csv")

    // Determine if we should add MaxNegControlEnrichment column
    // It should be added only if there are multiple control conditions (either >1 conditions or >0 conditions + sequenced library)
    addMaxNegControlEnrichment := antigenControlConfig.hasMultiConditionNegativeControl &&
		!(len(antigenControlConfig.controlConditionsOrder) == 1  &&
			antigenControlConfig.sequencedLibraryEnabled == false)
		
	addPresentInNegControl := antigenControlConfig.hasSingleConditionNegativeControl ||
		(antigenControlConfig.sequencedLibraryEnabled == false &&
			len(antigenControlConfig.controlConditionsOrder) == 1)

	enrichmentImportParams := pfEnrichmentConv.getColumns(abundanceSpec, conditionOrder, 
		antigenControlConfig.controlEnabled, addPresentInNegControl, 
		addMaxNegControlEnrichment, antigenControlConfig.sequencedLibraryEnabled)
	enrichmentPf := xsv.importFile(enrichCsv, "csv", enrichmentImportParams,
									{ cpu: 1, mem: "32GiB" })
	controlScatterPf := undefined
	if antigenControlConfig.controlEnabled {
		controlScatterImportParams := pfControlScatterConv.getColumns(abundanceSpec, 
			conditionOrder, addPresentInNegControl, addMaxNegControlEnrichment)
		controlScatterPf = xsv.importFile(enrichCsv, "csv", controlScatterImportParams,
			{ cpu: 1, mem: "32GiB" })
	}

	bubbleImportParams := pfBubbleConv.getColumns(abundanceSpec, addPresentInNegControl,
		addMaxNegControlEnrichment)
	bubblePf := xsv.importFile(calculateEnrichment.getFile("bubble_data.csv"), "csv", bubbleImportParams,
							{ cpu: 1, mem: "32GiB" })

	lineImportParams := pfStackedConv.getColumns(abundanceSpec, addPresentInNegControl, addMaxNegControlEnrichment)
	linePf := xsv.importFile(calculateEnrichment.getFile("top_10.csv"), "csv", lineImportParams,
							{ cpu: 1, mem: "32GiB" })

	stackedImportParams := pfStackedConv.getColumns(abundanceSpec, addPresentInNegControl, addMaxNegControlEnrichment)
	stackedPf := xsv.importFile(calculateEnrichment.getFile("top_enriched.csv"), "csv", stackedImportParams,
								{ cpu: 1, mem: "32GiB" })

	topEnrichedColCsv := calculateEnrichment.getFile("highest_enrichment_clonotype.csv")

	// Export frequency
	frequencyImportParams := pfFrequencyConv.getColumns(abundanceSpec, conditionOrder,
														inputType, downsampling,
														blockId, addPresentInNegControl,
														addMaxNegControlEnrichment,
														antigenControlConfig.sequencedLibraryEnabled)
	frequencyPf := xsv.importFile(enrichCsv, "csv", frequencyImportParams,
								{ cpu: 1, mem: "32GiB" })

	// Prepare pFrame to be exported
	trace := pSpec.makeTrace(abundanceSpec,
        {
            type: "milaboratories.clonotype-enrichment",
            importance: 30,
            label: label
        })

    exportsFreq := pframes.pFrameBuilder()
	for condition in conditionOrder {
		colId := strings.substituteSpecialCharacters("frequency_" + condition)
		exportsFreq.add(
			"Frequency " + condition, 
			trace.inject(frequencyPf[colId + ".spec"]), 
			frequencyPf[colId + ".data"]
		)
	}

	// Export additional enrichment comparisons if selected
	exportsAdditionalEnrichments := pframes.pFrameBuilder()
	if additionalEnrichmentExports != undefined && len(additionalEnrichmentExports) > 0 {
		vsPattern := text.re_compile(" vs ")
		for comparison in additionalEnrichmentExports {
			// Convert display name (e.g., "Treatment vs Control") to column ID format (enrichment_Treatment_Control)
			colId := strings.substituteSpecialCharacters("enrichment_" + vsPattern.replace(comparison, "_"))

			annotationStats := calculateAnnotationValues(enrichCsv, "Enrichment " + comparison)

			specLabel := {
				label: "Log2FC " + comparison
			}

			exportColumnRender := render.create(enrichmentColumnTpl, {
				min: annotationStats.min,
				max: annotationStats.max,
				median: annotationStats.median,
				mean: annotationStats.mean,
				cutoff: annotationStats.cutoff,
				overall75Percentile: annotationStats.overall75Percentile,
				abundanceSpec: abundanceSpec,
				inputType: inputType,
				topEnrichedColCsv: enrichCsv,
				downsampling: downsampling,
				FilteringConfig: FilteringConfig,
				conditionOrder: conditionOrder,
				antigenControlConfig: antigenControlConfig,
				enrichmentThreshold: args.enrichmentThreshold,
				blockId: blockId,
				specLabel: specLabel,
				customBlockLabel: args.customBlockLabel,
				defaultBlockLabel: args.defaultBlockLabel
			})

			exportsAdditionalEnrichments.add(
				"Enrichment - " + comparison,
				exportColumnRender.output("columnSpec"),
				enrichmentPf[colId + ".data"]
			)
		}
	}

	//////////// Calculate annotation values ////////////
	mainAnnotationStats := calculateAnnotationValues(topEnrichedColCsv, "Enrichment")

	buildExports := render.create(buildMainExportTpl, {
		abundanceSpec: abundanceSpec,
		inputType: inputType,
		topEnrichedColCsv: topEnrichedColCsv,
		min: mainAnnotationStats.min,
		max: mainAnnotationStats.max,
		median: mainAnnotationStats.median,
		mean: mainAnnotationStats.mean,
		cutoff: mainAnnotationStats.cutoff,
		overall75Percentile: mainAnnotationStats.overall75Percentile,
		downsampling: downsampling,
		FilteringConfig: FilteringConfig,
		conditionOrder: conditionOrder,
		antigenControlConfig: antigenControlConfig,
		enrichmentThreshold: args.enrichmentThreshold,
		blockId: blockId,
		customBlockLabel: args.customBlockLabel,
		defaultBlockLabel: args.defaultBlockLabel,
		filteredTooMuch: calculateEnrichment.getFileContent("filtered_too_much.txt")
	})

	exports := buildExports.output("exports")
	outStats := buildExports.output("outStats")

	// Define outputs
	outputs := {
			outStats: outStats,
			enrichmentPf: pframes.exportFrame(enrichmentPf),
			bubblePf: pframes.exportFrame(bubblePf),
			stackedPf: pframes.exportFrame(stackedPf),
			linePf: pframes.exportFrame(linePf),
			filteredTooMuch: buildExports.output("filteredTooMuch")
		}
	if antigenControlConfig.controlEnabled {
		outputs.controlScatterPf = pframes.exportFrame(controlScatterPf)
	}

	return {
		outputs: outputs,
		exports: {
			pf: exports,
			frequency: exportsFreq.build(),
			additionalEnrichments: exportsAdditionalEnrichments.build()
		}
	}	
})